#!/bin/bash

# This program takes as its arguments a program to run repeatedly. It runs one
# time and then when `re-run` is invoked again (from any process on the machine)
# it re-executes the original commands again in the original process.

function main() {
  local cmd="$@"
  local FIFO=/tmp/re-run.wait

  function is_running {
    # Check the fourth column of ps output for a given PID for the current
    # program name.
    ps -p $1 | grep $0 >/dev/null
  }

  # If no arguments are passed
  if [[ -z $cmd ]]; then
    # And the pipe exists
    if [[ -n $pid ]] && is_running $pid; then
      # then sent an ALRM signal to that process and be done
      kill -ALRM $pid
      exit 0
    else
      # otherwise clean up the PIDFILE and print the USAGE
      [[ -f $PIDFILE ]] && rm $PIDFILE
      echo "Usage: $(basename $0) [cmd]"
      echo ""
      echo "Once this utility has been invoked with a cmd then that cmd"
      echo "will be executed and will be re-executed every time this utility"
      echo "receives an ALRM signal."
      echo "To send this signal simple invoke this program with no arguments."
      exit 1
    fi
  fi

  # Otherwise arguments were passed and we will set up a function to
  # continually re-run them.
  function re-run-cmd {
    disable-wait
    sleep 1
    # As long as this process is running it should own this file
    echo $$ > $PIDFILE
    $cmd
    setup-wait
    wait %1
  }

  # We idle forever by waiting on a permanent subprocess that does nothing.
  function setup-wait {
    rm -f $FIFO && mkfifo $FIFO
    cat $FIFO &
  }

  function disable-wait {
    kill %1
  }

  # And establish that function as our hook for receiving the ALRM signal
  trap "re-run-cmd" ALRM

  # And put the current process' pid into the right pidfile
  echo $$ > $PIDFILE
  # While making sure to clean it up when we're done
  trap "rm -f $PIDFILE" EXIT

  # Establish the child process
  setup-wait

  # Then we send that signal to ourselves
  kill -ALRM $$

  # And pause until we receive a signal
  wait %1
}

main "$@"
