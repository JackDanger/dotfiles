alias gs='git status'
alias gu='git pull --no-tags --recurse-submodules'
alias gur='git pull --rebase --no-tags --recurse-submodules'
alias gl='git log'
alias glp='git log -p'
alias glpf='git log -p --follow'
alias log="git log --follow --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"
alias gp='git push'
alias gd='git diff'
alias gdc='git diff --cached'
alias ga='git add -A'
alias gap='git add --patch'
alias gc='git commit -v'
alias gca='git commit -v -a'
alias amend='git commit -v --amend'
alias fixup='git commit --amend -C HEAD'
alias gba='git branch -a'
alias merged="git branch --contains HEAD | grep master"
alias unmerged="git branch --no-merged master"
alias gbr="git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format='%(refname)' | cut -d / -f 3-"
alias gco='git checkout'
alias grm='git rm'
alias gmv='git mv'
alias clean='git clean -df'
alias copyhead='git rev-parse HEAD | pbcopy'
alias stash='git stash'
alias unstash='git stash pop'
alias fetch='git fetch --no-tags'
alias ibase='git rebase -i origin/master'
alias grc='git rebase --continue'
alias pr="git push -u origin HEAD && git cmp"
alias gsp="git commit -m 'updating subproject'"
alias gps="git pull --no-tags --recurse-submodules && git submodule update --init --recursive"
alias git-unadd="git rm --cached"
alias gpick="git cherry-pick"
alias hard="git reset --hard"
alias soft="git reset"
alias current_branch="git symbolic-ref HEAD 2>/dev/null | cut -c12-"

rebase() {
  if [[ -z "$1" ]]; then
    git rebase origin/master
  else
    git rebase $@
  fi
}

sha() {
  git rev-parse ${1-HEAD}
}


# Clones the repo from the provided URI and then cds into it
clone() {
  git clone --recursive $1 $2
  if [[ -n $2 ]]; then
    cd $2
  else
    cd $(basename $1 | sed s/\.git$//)
  fi
}

# Start a new remote branch and track it
publish() {
  if git remote | grep JackDanger; then
    command git push -u JackDanger HEAD
  else
    command git push -u origin HEAD
  fi
}

# Get the sha from which you divert from a specific other sha:
#
#   merge-base origin/green
#
# Or just compare to master:
#
#   merge-base
#
merge-base() {
  if [[ -n "$1" ]]; then
    command git merge-base $1 HEAD
  else
    command git merge-base master HEAD
  fi
}
# stolen from: http://stackoverflow.com/questions/342969/how-do-i-get-bash-completion-to-work-with-aliases
if [[ -z $ZSH ]]; then
  function make-completion-wrapper () {
      local function_name="$2"
      local arg_count=$(($#-3))
      local comp_function_name="$1"
      shift 2
      local function="
  function $function_name {
      ((COMP_CWORD+=$arg_count))
      COMP_WORDS=( "$@" \${COMP_WORDS[@]:1} )
      "$comp_function_name"
      return 0
  }"
      eval "$function"
  }

  # we create a _git_checkout_mine function that will do the completion for "gco"
  # using the completion function "_git"
  make-completion-wrapper _git _git_checkout_mine git checkout

  # we tell bash to actually use _git_checkout_mine to complete "gco"
  complete -o bashdefault -o default -o nospace -F _git_checkout_mine gco
  complete -o bashdefault -o default -o nospace -F _git_checkout_mine gl
  complete -o bashdefault -o default -o nospace -F _git_checkout_mine glp
  complete -o bashdefault -o default -o nospace -F _git_checkout_mine sha
fi;
