#!/bin/bash

last_container() {
  docker ps | tail +2 | tail -n -1 | awk '{print $1}'
}

alias dps="docker ps"

docker-kill () {
  if [[ -z $1 ]]; then
    echo "Usage: docker-kill [all|first|last|container_id]"
    return
  fi
  case $1 in
    all)
      docker ps | tail +2 | awk '{print $1 }' | xargs -n 1 docker kill
    ;;
    first)
      docker ps | tail +2 | awk '{print $1 }' | head -n 1 | xargs -n 1 docker kill
    ;;
    last)
      docker ps | tail +2 | awk '{print $1 }' | tail -n 1 | xargs -n 1 docker kill
    ;;
    *)
      docker ps | tail +2 | awk '{print $1 }' | grep $1 | xargs -n 1 docker kill
    ;;
  esac
}
alias dkill=docker-kill

# If in a directory with a Dockerfile build that dockerfile and immediately run
# the image that results, passing along all arguments as flags to `docker run`.
# Anything passed after the argument-final '--' will be passed as a runtime
# command for the docker container to execute
docker-build-and-run() {
  local image
  local args=('run')
  declare -a args
  local cmd

  USAGE=<<-EOUSAGE

    docker-build-and-run
    -> docker build .
    -> docker run THE_BUILT_IMAGE

    docker-build-and-run -P
    -> docker build .
    -> docker run -P THE_BUILT_IMAGE

    docker-build-and-run -P -p 2000:3000 -- sh -c "echo hello"
    -> docker build .
    -> docker run -P -p 2000:3000 THE_BUILT_IMAGE sh -c "echo hello"
EOUSAGE

  if [[ ! -f Dockerfile ]]; then
    echo $USAGE
    return 1
  fi

  build_out=$(2>&1 docker build .)
  if [[ 0 -ne $? ]]; then
    echo $build_out
    return 1
  fi

  image=$(tail -n 1 <<< $build_out | awk '{print $3}')
  # Is a command specified?
  if grep -q -- -- <<< $@; then
    # Clear out the args array and rebuild by hand.
    for token in "$@"; do
      [[ '--' == $token ]] && token=$image
      args+=($token)
    done
  else
    # Just append the image name, nothing fancy here.
    for token in "$@"; do
      args+=($token)
    done
    args+=($image)
  fi

  docker ${args[@]}
  return $?
}

